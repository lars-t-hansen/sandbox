package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
)

var (
	makeDoc  = flag.Bool("doc", false, "Produce markdown documentation")
	makeRust = flag.Bool("tag", false, "Produce Rust constant JSON field tags")
	warnings = flag.Bool("w", false, "Print warnings")
)

func main() {
	flag.Parse()
	if *makeDoc == *makeRust {
		fmt.Fprintf(os.Stderr, "Must use -doc xor -tag.  Try -h.\n")
		os.Exit(2)
	}
	switch {
	case *makeDoc:
		fmt.Print("# Sonar JSON format output specification\n\n")
		fmt.Print("AUTOMATICALLY GENERATED BY `process-doc`.  DO NOT EDIT.\n")
		fmt.Print("Instead, edit `util/formats/newfmt/types.go`, then in `util/process-doc` run `make install`.\n\n")

	case *makeRust:
		fmt.Print("// AUTOMATICALLY GENERATED BY `process-doc`.  DO NOT EDIT.\n")
		fmt.Print("// Edit `util/formats/newfmt/types.go`, then in `util/process-doc` run `make install`.\n\n")
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(
		fset,
		"<stdin>",
		os.Stdin,
		parser.ParseComments|parser.SkipObjectResolution,
	)
	if err != nil {
		log.Fatal(err)
	}

	for _, d := range f.Decls {
		if item, ok := d.(*ast.GenDecl); ok {
			switch item.Tok {
			case token.CONST:
				if item.Lparen.IsValid() {
					for _, s := range item.Specs {
						handleConst(s.(*ast.ValueSpec), nil)
					}
				} else {
					handleConst(item.Specs[0].(*ast.ValueSpec), item.Doc)
				}
			case token.TYPE:
				if item.Lparen.IsValid() {
					log.Fatal("Parenthesized types not supported")
				}
				if len(item.Specs) != 1 {
					log.Fatal("Unexpected structure")
				}
				td := item.Specs[0].(*ast.TypeSpec)
				name := td.Name.Name
				if name == "_preamble" || name == "_postamble" {
					printDoc(item.Doc)
					break
				}
				if st, ok := td.Type.(*ast.StructType); ok {
					handleStructType(item, td, st)
					break
				}
				// TODO: Type aliases.  Probably we want td.Type to be *ast.Ident in this case.
			}
		}
	}
}

func handleConst(v *ast.ValueSpec, d *ast.CommentGroup) {
	name := v.Names[0].Name
	switch {
	case *makeDoc:
		// No-op currently.
	case *makeRust:
		if len(v.Names) != 1 || len(v.Values) != 1 {
			log.Fatal("Unexpected constant form")
		}
		ty := "u64"
		value := v.Values[0].(*ast.BasicLit).Value
		if strings.HasPrefix(value, "\"") {
			ty = "&str"
		}
		fmt.Printf("pub const %s: %s = %s;\n", transformName(name), ty, value)
	}
}

func handleStructType(item *ast.GenDecl, td *ast.TypeSpec, st *ast.StructType) {
	switch {
	case *makeDoc:
		// The doc is attached to the GenDecl
		fmt.Printf("### Type: `%s`\n\n", td.Name.Name)
		printDoc(item.Doc)
		for _, f := range st.Fields.List {
			// TODO: Assert one name
			fname := f.Names[0].Name
			// TODO: The type here could be something complicated, but we should need to
			// handle at least *T, []T, and idents
			ftype := "SomeType"
			fmt.Printf("#### **`%s`** %s\n\n", fname, ftype)
			printDoc(f.Doc)
		}
	case *makeRust:
	}
}

// Not a comment on function

func printDoc(d *ast.CommentGroup) {
	if d != nil {
		//fmt.Println(len(d.List))
		for _, c := range d.List {
			fmt.Println(strings.TrimPrefix(c.Text, "// "))
		}
		fmt.Println()
	}
}

// Rust naming conventions: In a given name, the first capital letter X after a lower case
// letter is transformed to _X.
//
// TODO: _ should be inserted between the last two capitals of a run of capitals immediately
// followed by a lower case letter, so that 'CEClock' becomes '_CE_CLOCK_' no '_CECLOCK_'.

func transformName(n string) string {
	bs := []byte(n)
	name := ""
	for i := range bs {
		if i > 0 && isUpper(bs[i]) && !isUpper(bs[i-1]) {
			name += "_"
		}
		name += toUpper(bs[i])
	}
	return name
}

func isUpper(b uint8) bool {
	return b >= 'A' && b <= 'Z'
}

func isLower(b uint8) bool {
	return b >= 'a' && b <= 'z'
}

func toUpper(b uint8) string {
	if isLower(b) {
		return string(b - ('a' - 'A'))
	}
	return string(b)
}
