// A different type of search.
//
// In the early game, there are 2-3 legal moves per position but basically the "move toward food"
// strategy will always be best.  In the later game, there are 1-2 legal moves per position but
// there may be an advantage to moving away from food for a while, to get around an obstacle or to
// get out of a jam.
//
// That is, during the early game the dfs strategy in search.go is probably just fine, and it is
// only when that can't find a solution that we want to apply something else.
//
// The idea here is to branch out to explore strategies.  Consider food at (Fx,Fy) and ~Fx being
// abs(width-Fx) and ~Fy being abs(height-Fy), ie, the mirrored position on the board.  Consider a
// position P and legal moves M1 .. Mn from P.  We can generate new positions Q1, .., Qm (m <= n)
// from (P,M1,..,Mn) by different criteria, eg, move toward (~Fx,Fy), (Fx,~Fy), (~Fx,~Fy) as well as
// (Fx,Fy) and maybe even some random positions or some fixed positions, or, get as far away from
// (Fx,Fy) as possible, or, use as many moves to find food as possible, or ....  These new positions
// are generated by not-too-long move sequences which we record (eg, some factor of
// dist(snake,goal), or a constant number of moves, or even a random one).  We can then repeat this,
// culling positions we've seen before.  In the end we end up with a set of plans, some of which
// take us to (or close to) (Fx,Fy), and we can pick the best.  It's possible that after we have
// generated these plans we execute a determinstic dfs strategy from the endpoint to (Fx,Fy), if the
// plan does not find food.
//
// In the end we then record the plan, at least if the plan leads to food, and we execute the plan.

package main

import "fmt"

type bfsMover struct /* implements mover */ {
	s *Snake
}

func newBfsMover(s *Snake) mover {
	if initialMoves != 1 {
		panic("N != 1 not supported")
	}
	return &bfsMover{s}
}

func (_ *bfsMover) name() string {
	return fmt.Sprintf("Bfs")
}

func (bfs *bfsMover) autoMove() {
}
